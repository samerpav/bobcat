<html>
	<title>Tutorial #3 | WebGL Factory</title>
	<meta http-equiv="content-script-type" content="text/javascript">

	<body onLoad = 'tutorial3()'>
	<table border="1">
		<tr>
			<td>Scene:</td>
			<td>Current canvas 2D context:</td>
		</tr>
		<tr>
			<td><canvas id ='canvas' style="border: none;" width="300" height="300"></canvas></td>
			<td><canvas id ='textCanvas' style="border: none;" width="300" height="300"></canvas></td>
		</tr>
	</table>
	</br>
	<form>
	Front display&nbsp;&nbsp;&nbsp;&nbsp;: <input type="text" name="text" onkeyup="updateText(this, 0);" /><br />
	</form>
	<form>
	Back display&nbsp;&nbsp;&nbsp;&nbsp;: <input type="text" name="text" onkeyup="updateText(this, 1);" /><br />
	</form>
	<form>
	Top display&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <input type="text" name="text" onkeyup="updateText(this, 2);" /><br />
	</form>
	<form>
	Bottom display&nbsp;: <input type="text" name="text" onkeyup="updateText(this, 3);" /><br />
	</form>
	<form>
	Right display&nbsp;&nbsp;&nbsp;&nbsp;: <input type="text" name="text" onkeyup="updateText(this, 4);" /><br />
	</form>
	<form>
	Left display&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <input type="text" name="text" onkeyup="updateText(this, 5);" /><br />
	</form>
	
	<script type="text/javascript" src="base.js"></script> 
	<script type="text/javascript" src="fast.js"></script> 
	<script type="text/javascript" src="math.js"></script> 

	
	<script type="text/javascript"> 
	
		function updateText(text, idx){
			writeTextToCanvas(text.value, idx);
		}
	
		var textInput = "";
		var gl;
		var context2D;
		var cubeVertexPositionBuffer;
		var cubeVertexIndexBuffer;
		var cubeVertexTextureCoordBuffer;
		var textureLookUpBuffer;
		var lastTime = 0;
		var rotAngle = 0;
		var shaderProgram;
		var matrix4 = tdl.fast.matrix4;
		var animationFrame;
		var textures = [];	
		var shaderTextureIndices = [];
		
		function tutorial3(){
			initWebGL();
			createShaderProgram();
			if (!shaderProgram){
				return;
			}
			initBuffers();
			setUpTextArea();
			for (var ii = 0; ii< 6; ++ii){
				writeTextToCanvas('Type here!', ii);
			}
			
			gl.clearColor(0.5, 0.5, 0.5, 1.0);
			gl.enable(gl.DEPTH_TEST);
			
			requestAnimationFrame = window.mozRequestAnimationFrame;
			if (!requestAnimationFrame)
				requestAnimationFrame = window.webkitRequestAnimationFrame	;
			if (!requestAnimationFrame){
				alert ('Ooops');
				return;
			}
			animate();
		}
		
		function initWebGL(){
			canvas = document.getElementById('canvas');
			context2D = document.getElementById('textCanvas').getContext('2d');
		    var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
			for (var ii = 0; ii < names.length; ++ii) {
				try {
					gl = canvas.getContext(names[ii]);
				} catch(e) {}
				if (gl) {
					gl.viewportWidth = canvas.width;
					gl.viewportHeight = canvas.height;
					gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
					pMatrix = new Float32Array(16);
					matrix4.perspective(pMatrix, tdl.math.degToRad(45), gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
					for (var jj = 0; jj < 6; jj++){
						textures[jj] = gl.createTexture();
					}
					return;
				}
			}
			alert('Oops, something went wrong...');
		}
		
		function createShaderProgram(){
		    var vertexShaderSource = document.getElementById('vertexShader').text;
			var vertexShader = getShader(vertexShaderSource, 'vertex');
			if (!vertexShader)
				return;
				
			var fragmentShaderSource = document.getElementById('fragmentShader').text;
			var fragmentShader = getShader(fragmentShaderSource,  'fragment');
			if (!fragmentShader)
				return;

			shaderProgram = gl.createProgram();
			gl.attachShader(shaderProgram, vertexShader);
			gl.attachShader(shaderProgram, fragmentShader);
			gl.linkProgram(shaderProgram);

			if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
				alert(gl.getProgramInfoLog(shader));
				return;
			}
			gl.useProgram(shaderProgram);
			
			shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
			gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
			
			shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
			gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
			
			shaderProgram.textureLookUpAttribute = gl.getAttribLocation(shaderProgram, "aFace");
			gl.enableVertexAttribArray(shaderProgram.textureLookUpAttribute);
			
			shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
			shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
			
			shaderTextureIndices[0] = gl.getUniformLocation(shaderProgram, "front");
			shaderTextureIndices[1] = gl.getUniformLocation(shaderProgram, "back");
			shaderTextureIndices[2] = gl.getUniformLocation(shaderProgram, "top");
			shaderTextureIndices[3] = gl.getUniformLocation(shaderProgram, "bottom");
			shaderTextureIndices[4] = gl.getUniformLocation(shaderProgram, "right");
			shaderTextureIndices[5] = gl.getUniformLocation(shaderProgram, "left");
		
			return;
		}
		
		function setUpTextArea(){
			context2D.font = 'normal 35px Verdana';
			context2D.fillStyle = 'rgba(0,0,0,255)';
			context2D.fillRect(0,0, 300, 300);
			context2D.lineWidth = 5;
		    context2D.strokeStyle = 'rgba(0,0,0,255)';
			context2D.textAlign = 'center';
			context2D.textBaseline = 'middle';
		}
		
		var faceColors = ['rgba(0, 0, 255, 255)', 'rgba(255, 0, 0, 255)', 'rgba(0, 255, 0, 255)', 'rgba(0, 0, 0, 255)', 'rgba(255, 0, 255, 255)', 'rgba(0, 255, 255, 255)'];
		
		function writeTextToCanvas(text, idx){
			context2D.save();
		
			context2D.clearRect ( 0 , 0 , 300 , 300);
			context2D.fillStyle = faceColors[idx];
			context2D.fillRect(0,0, 300, 300);
			
			context2D.fillStyle = 'rgba(255, 255, 255, 255)';
			context2D.strokeText(text, 150, 150);
			context2D.fillText(text, 150, 150);
			
			setTextureFromCanvas(context2D.canvas, textures[idx], idx);
			
			context2D.restore();
		
		}
		
		
		function getShader(shaderCode, shaderType) {

			var shader;
			if (shaderType == 'vertex') {
				shader = gl.createShader(gl.VERTEX_SHADER);	
			} else if (shaderType == 'fragment') {
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else {
				alert('Unsupported shader type');
				return null;
			}

			gl.shaderSource(shader, shaderCode);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				alert(gl.getShaderInfoLog(shader));
				return null;
			}

			return shader;
		}
		
		function initBuffers() {
			cubeVertexPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
			
			 var cubeVertices = [
			// Front face
			-1.0, -1.0,  1.0,
			1.0, -1.0,  1.0,
			1.0,  1.0,  1.0,
			-1.0,  1.0,  1.0,

			// Back face
			-1.0, -1.0, -1.0,
			-1.0,  1.0, -1.0,
			1.0,  1.0, -1.0,
			1.0, -1.0, -1.0,

			// Top face
			-1.0,  1.0, -1.0,
			-1.0,  1.0,  1.0,
			1.0,  1.0,  1.0,
			1.0,  1.0, -1.0,

			// Bottom face
			-1.0, -1.0, -1.0,
			1.0, -1.0, -1.0,
			1.0, -1.0,  1.0,
			-1.0, -1.0,  1.0,

			// Right face
			1.0, -1.0, -1.0,
			1.0,  1.0, -1.0,
			1.0,  1.0,  1.0,
			1.0, -1.0,  1.0,

			// Left face
			-1.0, -1.0, -1.0,
			-1.0, -1.0,  1.0,
			-1.0,  1.0,  1.0,
			-1.0,  1.0, -1.0,
			];
			
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertices), gl.STATIC_DRAW);
			cubeVertexPositionBuffer.itemSize = 3;
			cubeVertexPositionBuffer.numItems = 24;
			
			cubeVertexTextureCoordBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
			var textureCoords = [
			// Front face
				0.0, 0.0,
				1.0, 0.0,
				1.0, 1.0,
				0.0, 1.0,
 
				// Back face
				1.0, 0.0,
				1.0, 1.0,
				0.0, 1.0,
				0.0, 0.0,
 
				// Top face
				0.0, 1.0,
				0.0, 0.0,
				1.0, 0.0,
				1.0, 1.0,
 
				// Bottom face
				1.0, 1.0,
				0.0, 1.0,
				0.0, 0.0,
				1.0, 0.0,
 
				// Right face
				1.0, 0.0,
				1.0, 1.0,
				0.0, 1.0,
				0.0, 0.0,
 
				// Left face
				0.0, 0.0,
				1.0, 0.0,
				1.0, 1.0,
				0.0, 1.0,
			];
			
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
			cubeVertexTextureCoordBuffer.itemSize = 2;
			cubeVertexTextureCoordBuffer.numItems = 24;
			
			textureLookUpBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, textureLookUpBuffer);
			var lookUpArray = [
				// Front face
				0.0, 0.0, 0.0, 0.0, 
 
				// Back face
				1.0, 1.0, 1.0, 1.0, 
				
								// Back face
				2.0, 2.0, 2.0, 2.0, 

								// Back face
				3.0, 3.0, 3.0, 3.0, 

								// Back face
				4.0, 4.0, 4.0, 4.0, 

								// Back face
				5.0, 5.0, 5.0, 5.0
			];
			
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lookUpArray), gl.STATIC_DRAW);
			textureLookUpBuffer.itemSize = 1;
			textureLookUpBuffer.numItems = 24;
 
			cubeVertexIndexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
			var cubeVertexIndices = [
				0, 1, 2,      0, 2, 3,    // Front face
				4, 5, 6,      4, 6, 7,    // Back face
				8, 9, 10,     8, 10, 11,  // Top face
				12, 13, 14,   12, 14, 15, // Bottom face
				16, 17, 18,   16, 18, 19, // Right face
				20, 21, 22,   20, 22, 23  // Left face
			];
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
			cubeVertexIndexBuffer.itemSize = 1;
			cubeVertexIndexBuffer.numItems = 36;
			
		}

		function setTextureFromCanvas(canvas, textTexture, idx) {
		    gl.activeTexture(gl.TEXTURE0 + idx);
			gl.bindTexture(gl.TEXTURE_2D, textTexture);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
			if (isPowerOfTwo(canvas.width) && isPowerOfTwo(canvas.height)){
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			}else{
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			}
			
			
			gl.bindTexture(gl.TEXTURE_2D, textTexture);
			gl.uniform1i(shaderTextureIndices[idx], idx); 
			
			//gl.bindTexture(gl.TEXTURE_2D, null);
		}
 
	
		function isPowerOfTwo(value) {
			return ((value & (value - 1)) == 0);
		}
  
		
		function updateTimer() {
			var timeNow = new Date().getTime();
			if (lastTime != 0) {
				var elapsed = timeNow - lastTime;
				rotAngle += (9 * elapsed) / 10000.0;
			}
			lastTime = timeNow;
		}
		

		function animate() {
			requestAnimationFrame(animate);
			render();
			updateTimer();
		}
		
		function render() {
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			

			var mvMatrix = new Float32Array(16);
			matrix4.identity(mvMatrix);
			
			matrix4.translate(mvMatrix, [0, 0.0, -7.0]);
			matrix4.rotateY(mvMatrix, - 0.5 *rotAngle);
			matrix4.rotateX(mvMatrix, rotAngle);
			matrix4.rotateZ(mvMatrix, rotAngle / 2);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
			gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, textureLookUpBuffer);
			gl.vertexAttribPointer(shaderProgram.textureLookUpAttribute, textureLookUpBuffer.itemSize, gl.FLOAT, false, 0, 0);
			
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);

			setUniforms(shaderProgram, pMatrix, mvMatrix);
			gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		}
		
		function setUniforms(shaderProgram, pMatrix, mvMatrix) {
			gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
			gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
		}
		
	</script>
	
	<script id="fragmentShader" type="GLSL_shader"> 
		#ifdef GL_ES
		precision highp float;
		#endif
		
		uniform sampler2D front;
		uniform sampler2D back;
		uniform sampler2D top;
		uniform sampler2D bottom;
		uniform sampler2D right;
		uniform sampler2D left;
 
		varying vec2 vTextureCoord;
		
		varying float vFace;
 
		void main(void) {
		if (vFace < 0.1)
			gl_FragColor = texture2D(front, vTextureCoord);
		else if (vFace < 1.1)
			gl_FragColor = texture2D(back, vTextureCoord);
		else if (vFace < 2.1)
			gl_FragColor = texture2D(top, vTextureCoord);
		else if (vFace < 3.1)
			gl_FragColor = texture2D(bottom, vTextureCoord);
		else if (vFace < 4.1)
			gl_FragColor = texture2D(right, vTextureCoord);
		else 
			gl_FragColor = texture2D(left, vTextureCoord);
		}
	</script> 
 
	<script id="vertexShader" type="GLSL_shader"> 
		attribute vec3 aVertexPosition;
		attribute vec2 aTextureCoord;
		attribute float aFace;
 
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
 
		varying vec2 vTextureCoord;
		varying float vFace;
 
 
		void main(void) {
			gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			vTextureCoord = aTextureCoord;
			vFace = aFace;
		}
	</script> 	

	</body>
</html>
