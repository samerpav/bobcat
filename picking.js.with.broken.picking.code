var ps, lobby;

// Create an orbit camera halfway between the closest and farthest point
var cam = new OrbitCam({closest:1, farthest:150, distance: 30});
var rotationStartCoords = [0, 0];
var isDragging = false;

var panStartCoords = [0, 0];
var isRightDragging = false;

var HPanning = V3.$( 1, 0, 0);
var VPanning = V3.$( 0, 0, 1);
var up = V3.$( 0, 1, 0);

var accumX = 0;
var accumY = 0;

var isPresetView = false;

var pickX = 0;
var pickY = 0;

var isInPickMode = false;

const KEY_ESC = 27;

function zoom(amt){
  if(amt < 0){
    cam.goCloser(-amt*2);
  }
  else{
    cam.goFarther(amt*2);
  }
}

function mousePressed(RightClick){
  if (RightClick) {
	panStartCoords[0] = ps.mouseX;
  	panStartCoords[1] = ps.mouseY;
	isRightDragging = true;
  }
  else {
	rotationStartCoords[0] = ps.mouseX;
  	rotationStartCoords[1] = ps.mouseY;
  	isDragging = true;
  }
}

function mouseReleased(){
  isRightDragging = false;
  isDragging = false;
  isPresetView = false;
}

function keyDown(){
  if(ps.key == KEY_ESC){
    ps.stop("/clouds/parking-lot.pts");
  }

  if (ps.key == 48) isInPickMode = true;
  if (ps.key == 49) cam.setPosition( [10, 0, 0] ); // 1
  if (ps.key == 50) cam.setPosition( [0, 0, 10] );
  if (ps.key == 51) cam.setPosition( [-10, 0, 0] );
  if (ps.key == 52) cam.setPosition( [0, 0, -10] );
  if (ps.key == 53) cam.setPosition( [10, 10, 10] );

}

//var newPos;
var newCenter = [0, 0, 0];
var offsetX = 0;
var offsetY = 0;

function render() {

  if (isPresetView === true) {
    cam.setPosition([10, 0, 0]);
    isPresetView = false;
  }
  else if(isDragging === true){		
    var deltaX = ps.mouseX - rotationStartCoords[0];
    var deltaY = ps.mouseY - rotationStartCoords[1];
    rotationStartCoords = [ps.mouseX, ps.mouseY];

    cam.yaw(-deltaX * 0.015); // 0.015 indicates how fast yaw is done
    cam.pitch(deltaY * 0.015);
  }

  if (isRightDragging === true) {
   //lion.setCenter([-10, -4, 0]);
   //console.log(lion.getCenter());
   
   offsetX += ps.mouseX - panStartCoords[0];
   offsetY += ps.mouseY - panStartCoords[1];
   panStartCoords = [ps.mouseX, ps.mouseY];

   HPanning = V3.cross(cam.direction, up);
   VPanning = V3.cross(cam.direction, HPanning);

   console.log(offsetY);
  }
  else {
    HPanning = V3.$( 1, 0, 0);
    VPanning = V3.$( 0, 0, 1);
  }

  var newPos = V3.add(cam.position, V3.scale(HPanning, -1));
  newPos = V3.add(newPos, V3.scale(VPanning, -1)); 
  
  //var newPos = V3.add(cam.position, V3.scale(HPanning, -offsetX));
  //newPos = V3.add(newPos, V3.scale(VPanning, -offsetY)); 

  //lion.setCenter(newPos);

  var c = lion.getCenter();
  ps.multMatrix(M4x4.makeLookAt(cam.position, cam.direction, cam.up));

  newPos = cam.position;
  ps.translate(-newPos[0]-c[0], -newPos[1]-c[1], -newPos[2]-c[2]);

  if (isInPickMode===true) {

 	var vx, vy, vz, i, j;
	var rval = false;  	


  	// Viewport Space to NDC to Clip Space
  	vx = ps.mouseX;
  	vy = ps.mouseY;
  	vz = 0.0;                 // By setting vz to 0 we will compute a ray passing through v
	
	// NDC coordinates
	var nx = 2.0*vx/(1000) - 1.0;
	var ny = 1.0 - 2.0*vy/(600);
	var nz = 2*vz - 1.0;
	var nw = 1.0;
	
	var c = Vector.create([nx, ny, nz, nw]);      // Clip coordinates same as NDC coordinates

	perspectiveInv(60, 1.667, 0.1, 1000);    //fov, aspect, near, far

	// Clipping Space to View Space
	var v = pMatrixInv.x(c);
	
	// Rescale
	v.elements[0] = v.elements[0] / v.elements[3];
	v.elements[1] = v.elements[1] / v.elements[3];
	v.elements[2] = v.elements[2] / v.elements[3];
	v.elements[3] = 1.0;

	var mvPickMatrix = ps.peekMatrix();

	var R2 = M4x4.topLeft3x3(mvPickMatrix);
	var R = Matrix.create( [
		      [R2[0], R2[1], R2[2]],
		      [R2[3], R2[4], R2[5]],
		      [R2[6], R2[7], R2[8]]
		   ]);

	var Rt = R.transpose();

	var t = Vector.create([ mvPickMatrix[3], mvPickMatrix[7], mvPickMatrix[11]  ]);

	var tp = Rt.x(t);

	var mvPickMatrixInv = Matrix.I(4);

	for (i=0; i < 3; i++) {
		for (j=0; j < 3; j++) {
			mvPickMatrixInv.elements[i][j] = Rt.elements[i][j];
		}	
		mvPickMatrixInv.elements[i][3] = -1.0 * tp.elements[i];
        }	
	
	var ray_start_point = Vector.create([ 0.0, 0.0, 0.0, 1.0 ]);
	
	// v = point in view space
	// w = point in world space

	v.elements[3] = 0;                 // Make v a ray in view coordinates
	var w = mvPickMatrixInv.x(v);      // w is now a ray in world coordinates

	var a = mvPickMatrixInv.x(ray_start_point);
   
	var anchor = Vector.create([ a.e(1), a.e(2), a.e(3) ]);
	var direction = Vector.create([ w.e(1), w.e(2), w.e(3) ]);

	var l = Line.create(anchor, direction.toUnitVector());
	console.dir(l.anchor.inspect());
	console.dir(l.direction.inspect());
	
	// Perform intersection test between ray l and world geometry (cube)
	/*
	anchor = Vector.create([ 0, 0, 1 ]);    // Point on the front face of cube
	var normal = Vector.create([0, 0, 1 ]);  // Normal of front face of cube
	
	var p = Plane.create(anchor, normal);   // Plane representing a cubes front face
	
	// Check if line l and plane p intersect
	if (l.intersects(p)) {
		var intersectionPt = l.intersectionWith(p);
		if ((intersectionPt.e(1) >= -1.0) && (intersectionPt.e(1) <= 1.0) &&
		    (intersectionPt.e(2) >= -1.0) && (intersectionPt.e(2) <= 1.0) ) {
		    rval = true;        // intersection point is on the cubes front face
		}
	}
	*/

	//var distance = l.pointClosestTo( $V([-9.653, 6.115, -6.494]) );
	//alert(distance.inspect());
	//debugger;

	isInPickMode = false;
  }

  ps.clear();
  ps.render(lion);
}


  var pMatrixInv;
  function perspectiveInv(fovy, aspect, znear, zfar) {
    pMatrixInv = makePerspectiveInv(fovy, aspect, znear, zfar);
  } 

  function makePerspectiveInv(fovy, aspect, znear, zfar)
  {
    var ymax = znear * Math.tan(fovy * Math.PI / 360.0);
    var ymin = -ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;

    return makeFrustumInv(xmin, xmax, ymin, ymax, znear, zfar);
  }


  function makeFrustumInv(left, right,
                     bottom, top,
                     znear, zfar)
  {
    var X = 2*znear/(right-left);
    var Y = 2*znear/(top-bottom);
    var A = (right+left)/(right-left);
    var B = (top+bottom)/(top-bottom);
    var C = -(zfar+znear)/(zfar-znear);
    var D = -2*zfar*znear/(zfar-znear);

    return $M([[1/X, 0, 0, A/X],
               [0, 1/Y, 0, B/Y],
               [0, 0, 0, -1],
               [0, 0, 1/D, C/D]]);
  }


function start(){
  ps = new PointStream();
  ps.setup(document.getElementById('canvas'));
  ps.background([0.0, 0.0 ,0.0 ,1]);
  ps.pointSize(0.2);

  //ps.resize(window.innerWidth, window.innerHeight);
  ps.onRender = render;
  ps.onMouseScroll = zoom;
  ps.onMousePressed = mousePressed;
  ps.onMouseReleased = mouseReleased;
  ps.onKeyDown = keyDown;
  
  //lion = ps.load("/clouds/lion.asc");
  //lion = ps.load("/clouds/lobby.pts");
  //lion = ps.load("/clouds/indoor.pts");
  //lion = ps.load("/clouds/parking-lot-3M.pts");
  //lion = ps.load("/clouds/test.pts");
  lion = ps.load("/clouds/parking-lot-2.pts");

}
